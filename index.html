<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="noindex" />
<title>FBLA Sponsors</title>

<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

<style>
  html, body {
    height: 100%;
    margin: 0;
  }
  body {
    font-family: 'Montserrat', sans-serif;
    background: #f3f3f3;
    display: flex;
    justify-content: center;
    overflow: hidden;
  }
  canvas {
    display: block;
    text-rendering: geometricPrecision;
    -webkit-font-smoothing: none;
    background: #f3f3f3; /* fallback/background */
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
let DPR = window.devicePixelRatio || 1;
const ctx = canvas.getContext('2d', { alpha: false }); // Option 2: disable transparency

function resizeCanvas() {
  DPR = window.devicePixelRatio || 1;
  canvas.width = Math.round(window.innerWidth * DPR);
  canvas.height = Math.round(window.innerHeight * DPR);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  // Set transform so 1 unit in canvas drawing = 1 CSS pixel
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- Immediately paint background to avoid black flash ---
ctx.save();
ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
ctx.fillStyle = "#f3f3f3";
ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
ctx.restore();

// --- Style constants ---
const TEXT_COLOR = "#081f3f";
const FONT_WEIGHT = 675;           // slightly thicker than default
const FONT_FAMILY = "Montserrat, sans-serif";
const FONT_SIZE = 36;              // matches Past Meetings title
const FONT = `${FONT_WEIGHT} ${FONT_SIZE}px ${FONT_FAMILY}`;
const UNDERLINE_WIDTH = 50;
const UNDERLINE_HEIGHT = 4;
const UNDERLINE_OFFSET = 8;

const initialText = "FBLA Sponsors";
const secretText = "Daddy Davin";

let clickTimestamps = [];
const maxClicks = 10;
const quickTime = 2000;

let shards = [];
let animationRunning = false;
const TOP_MARGIN = 100;

function getTopCenter() {
  return { x: Math.round(window.innerWidth / 2), y: TOP_MARGIN };
}

function generateShardShape(width, height) {
  const points = [];
  const numPoints = 3 + Math.floor(Math.random() * 4);
  for (let i = 0; i < numPoints; i++) {
    points.push({
      x: Math.random() * width - width / 2,
      y: Math.random() * height - height / 2
    });
  }
  return points;
}

function createShards(centerX, centerY) {
  // ensure we're using CSS-pixel coordinates for measurements
  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.font = FONT;
  const textWidth = ctx.measureText(initialText).width;
  ctx.restore();

  const startX = centerX - textWidth / 2;
  const startY = centerY;
  shards = [];

  const numChunks = 20;
  for (let i = 0; i < numChunks; i++) {
    const shardWidth = textWidth / numChunks;
    const x = startX + i * shardWidth + (Math.random() - 0.5) * 5;
    const y = startY + (Math.random() - 0.5) * 4;
    const chunkText = initialText.substr(
      Math.floor(i * initialText.length / numChunks),
      Math.ceil(initialText.length / numChunks)
    );

    const numFragments = 2 + Math.floor(Math.random() * 2);
    for (let f = 0; f < numFragments; f++) {
      const fragWidth = Math.max(10, shardWidth / numFragments);
      const fragHeight = Math.max(10, FONT_SIZE * 0.75);
      shards.push({
        x: x + Math.random() * fragWidth,
        y: y + Math.random() * 4,
        vx: (Math.random() - 0.5) * 12,
        vy: (Math.random() - 1.2) * 14,
        ax: 0,
        ay: 0.9,
        rotation: Math.random() * Math.PI * 2,
        vr: (Math.random() - 0.5) * 0.3,
        width: fragWidth,
        height: fragHeight,
        text: chunkText,
        shape: generateShardShape(fragWidth, fragHeight)
      });
    }
  }
}

function drawTextWithUnderline(txt, centerX, centerY) {
  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // ensure CSS-pixel coords
  ctx.font = FONT;
  ctx.fillStyle = TEXT_COLOR;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // round coordinates to avoid subpixel differences
  const px = Math.round(centerX);
  const py = Math.round(centerY);
  ctx.fillText(txt, px, py);

  const underlineX = px - UNDERLINE_WIDTH / 2;
  const underlineY = py + (FONT_SIZE / 2) + UNDERLINE_OFFSET;
  ctx.fillRect(underlineX, underlineY, UNDERLINE_WIDTH, UNDERLINE_HEIGHT);
  ctx.restore();
}

function drawShard(s) {
  // shards are positioned in CSS-pixel coordinates, so draw using DPR transform
  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.translate(s.x + s.width / 2, s.y);
  ctx.rotate(s.rotation);
  ctx.beginPath();
  ctx.moveTo(s.shape[0].x, s.shape[0].y);
  for (let i = 1; i < s.shape.length; i++) ctx.lineTo(s.shape[i].x, s.shape[i].y);
  ctx.closePath();
  ctx.fillStyle = TEXT_COLOR;
  ctx.fill();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.stroke();

  ctx.font = `500 ${Math.round(FONT_SIZE * 0.6)}px ${FONT_FAMILY}`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#fff";
  ctx.fillText(s.text, 0, 0);
  ctx.restore();
}

function animate() {
  animationRunning = true;

  // Force full repaint in the SAME coordinate space (use DPR transform)
  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);                 // draw in CSS pixels
  ctx.globalCompositeOperation = "copy";                  // replace pixels
  ctx.fillStyle = "#f3f3f3";                              // match page bg
  ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
  ctx.restore();

  const center = getTopCenter();
  drawTextWithUnderline(secretText, center.x, center.y);

  const floor = window.innerHeight - 8;
  for (let s of shards) {
    s.vy += s.ay;
    s.vx += s.ax;
    s.rotation += s.vr;
    s.x += s.vx;
    s.y += s.vy;
    if (s.y > floor) {
      s.y = floor;
      s.vy *= -0.45;
      s.vx *= 0.82;
      s.vr *= 0.88;
    }
    if (s.x < 0) { s.x = 0; s.vx *= -0.65; }
    if (s.x + s.width > window.innerWidth) { s.x = window.innerWidth - s.width; s.vx *= -0.65; }
    drawShard(s);
  }

  // continue
  requestAnimationFrame(animate);
}

canvas.addEventListener('click', () => {
  const now = Date.now();
  clickTimestamps.push(now);
  clickTimestamps = clickTimestamps.filter(t => now - t < quickTime);
  if (clickTimestamps.length >= maxClicks && !animationRunning) {
    const center = getTopCenter();
    createShards(center.x, center.y);
    animate();
  }
});

(function initialDraw() {
  // paint background cleanly in correct coordinate space
  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.fillStyle = "#f3f3f3";
  ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
  ctx.restore();

  const center = getTopCenter();
  drawTextWithUnderline(initialText, center.x, center.y);
})();
</script>
</body>
</html>
